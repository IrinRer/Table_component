## Описание 

Таблица с данными, с возможностью фильтра по статусу и типу, а также с сортировкой данных по возрастанию и убыванию.

## Технологии 

1. React
2. TypeScript
3. Redux (thunk, redux-toolkit)
4. JSON-server
5. CSS modules
6. Axious

## Что было сделано

1. JSON-server использовался для создания сервера, к которому будут делаться запросы. Запросы делала с помощью middleware - thunk. Store создавала с помощью Redux-toolkit.

2. Базу данных сформирована в соответствие с потребностями.

Есть поле *status*, которое содержит массив. Делаю запрос к серверу в thunk, получаю этот массив, который использую для фильтрации по статусам. 

``"status": ["green", "yellow", "red"]``

Есть поле *type*. Делаю запрос к серверу в thunk, получаю этот массив, который использую для фильтрации по типу. 

``  "type": ["TRST", "THT"] ``

Поле *data* содержит основные данные по которым будет строиться таблица.  

``` 
   {
      "id": 1,
      "name": "Pyshky.net",
      "status": "green",
      "type": "TRST",
      "conditions": "x2,6 months",
      "volume": 120000,
      "roi": 4,
      "free": 20,
      "hedge": 20
    }
```    

3. Вспомогательная функция api, которая позволят создовать объект axios с нужными заголовками.

```
export const api = (): AxiosInstance => {
  return axios.create({
    baseURL: getBackendURL(),
  });
};
```

В thunk нужно просто вызывать эту функцию. Это позволяет избежать дублирования кода.

4. Есть два *actions*, которые я использую для сортировки. 

**onSortUp** - сортирует по возрастанию.

**onSortDown** - сортирует по убыванию. 

Они принимают в себя *action*, который в *payload* содержит строку, указывающую на поле, в котором происходит сортировка. Таким образом, я избегаю дублирования кода, так как при передачи поля, его можно использовать для доступа к свойству в объекте.

```
state.dataFilter = state.dataFilter.sort(
        (a, b) => b[action.payload] - a[action.payload]);
```
5. Фильтрация осуществляется по статусу и по типу. 

Если пользователь установит фильтрацию по статусу, например **green**, то будут отображаться те данные, которые имеют `` status: green ``, при этом пользователь также может осуществить фильтрацию по типу, например **TRST**, тогда будут отображаться данные, которые имеют: 

`` {status: greeen, type: TRST} ``

То есть фильтрация может идти как по двум полям, так и по одному. 

6. Форматирование данные. 

С сервера приходит ``volume: 20000``, по ТЗ в таблице должно отображаться *20 000*, для этого нужно сделать форматирование.

`` item.volume.toLocaleString('ru-RU') ``

С сервера приходит ``conditions: "x2,6 months" ``, по ТЗ в таблице должно отображаться *x 2,6 months*, для этого я провожу форматирование. 

``${item.conditions[0]} ${item.conditions.slice(1)}``

7. При нажатии на кнопку *Buy* объект перемещается в массив покупок. 

```
state.buy = state.buy.concat(
        state.data.filter((item) => item.id === action.payload),
      );
```

Использую *concat* для того, чтобы объединить старый массив, с новыми данными. 

8. Если объект, находится в массиву покупок, то нельзя нажать на кнопку *Buy*. 

``<button disabled={id.includes(String(item.id))}/> ``

**id** - это строка, которая содержит все id, объектов, которые были куплены. 

## Как запустить 

1. Клонируете репозиторий

``git clone https://github.com/IrinRer/Table_component.git``

2. Устанавливаете зависимости

``npm i``

3. Запускаете проект
``npm run dev``

Данная команда запустит также JSON-server.

**Версия node: v14.17.3**
